üîß Prompt for Replit AI

(Fix 401 ‚ÄúInvalid credentials‚Äù ‚Äì make login actually work + seed admin & test user)

Right now, my /api/auth/login endpoint always returns:

401 Unauthorized
Login failed ‚Äì Invalid credentials


even when I try to log in with users that I already signed up.

I need you to fix the authentication so that valid email/password logins succeed, and invalid ones fail.
This must work for:

Normal users created via Sign Up

A fixed admin user

Please modify the existing project, do not start a new one.

1. Verify and fix the users table schema

Make sure the SQLite users table has at least:

id

email (unique)

password_hash (string)

is_admin (boolean, default false)

created_at

If the password column is called something else (e.g. password), rename it in the code so that both signup and login use the same field name.

Add a unique constraint on email if it doesn‚Äôt already exist.

2. Fix Sign Up: user must be saved correctly

Open the signup route (e.g. POST /api/auth/signup):

Ensure it:

Reads email and password from req.body.

Normalizes email (trim + lowercase).

Checks if a user with that email already exists; if yes, returns 400.

Hash the password using bcrypt:

const bcrypt = require('bcrypt');
const hashed = await bcrypt.hash(password, 10);


Save the user with:

await User.create({
  email: normalizedEmail,
  password_hash: hashed,
  is_admin: false
});


Do not store the plain-text password.

From now on, all newly registered users must have a valid password_hash that can be verified at login.

3. Fix Login logic (401 bug)

Open the login route (e.g. POST /api/auth/login):

Normalize the email exactly the same way as in signup (trim + lowercase).

Look up the user:

const user = await User.findOne({ where: { email: normalizedEmail } });
if (!user) {
  return res.status(401).json({ message: 'Invalid credentials' });
}


Compare password using bcrypt with the correct field:

const bcrypt = require('bcrypt');
const isValid = await bcrypt.compare(password, user.password_hash);
if (!isValid) {
  return res.status(401).json({ message: 'Invalid credentials' });
}


Only if isValid is true:

Create the auth token / session (JWT or cookie) exactly as you already do.

Return 200 with user data, including is_admin.

Add a small debug log (only temporarily) to confirm where failures happen:

console.log('[LOGIN]', { email: normalizedEmail, found: !!user, isValid });


but do not log the plain password.

4. Seed a fixed admin user and a test normal user

After DB initialization (models sync/migrations), create a function and call it on server startup:

async function seedUsers() {
  const bcrypt = require('bcrypt');

  // Admin user
  const adminEmail = 'analfistt@proton.me';
  const adminPassword = 'King2003!';
  const adminHash = await bcrypt.hash(adminPassword, 10);

  let admin = await User.findOne({ where: { email: adminEmail } });
  if (!admin) {
    admin = await User.create({
      email: adminEmail.toLowerCase(),
      password_hash: adminHash,
      is_admin: true,
    });
    console.log('Admin user created:', adminEmail);
  } else {
    admin.is_admin = true;
    admin.password_hash = adminHash;
    await admin.save();
    console.log('Admin user ensured:', adminEmail);
  }

  // Regular test user
  const userEmail = 'testuser@example.com';
  const userPassword = 'Test1234!';
  const userHash = await bcrypt.hash(userPassword, 10);

  let user = await User.findOne({ where: { email: userEmail } });
  if (!user) {
    user = await User.create({
      email: userEmail.toLowerCase(),
      password_hash: userHash,
      is_admin: false,
    });
    console.log('Test user created:', userEmail);
  }
}


Call await seedUsers(); once, after the DB sync completes.

This guarantees:

I can always log in as admin with
email: analfistt@proton.me, password: King2003!

I can log in as a normal user with
email: testuser@example.com, password: Test1234!

5. Ensure the frontend sends the credentials correctly

Check the login API call in the frontend:

It must send email and password exactly as expected by the backend:

await fetch('/api/auth/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  credentials: 'include',        // if using cookies
  body: JSON.stringify({ email, password }),
});


Do not rename the fields or wrap them differently (e.g. { user: { email, password } }) unless the backend expects that.

6. Do NOT change anything else

Do not touch deposits, arbitrage logic, charts, WebSockets, or dashboard design.

Only modify:

users model/schema (if needed)

signup route

login route

small startup seed function

the login API call if it sends the wrong payload

‚úÖ Expected result

After these changes:

Logging in with
email: analfistt@proton.me
password: King2003!
should succeed on the first click and return 200 (no more 401).

Logging in with
email: testuser@example.com
password: Test1234!
should also succeed.

Any wrong email/password combination should still return 401 with ‚ÄúInvalid credentials‚Äù.