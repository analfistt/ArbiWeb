üîß Prompt for Replit AI

Fix user auth end-to-end (SQLite + signup + login + seeding) so valid users can log in without 401 ‚Äì once and for all

My app is a full-stack crypto arbitrage platform with:

SQLite database

/api/auth/signup and /api/auth/login

React login/signup pages

Right now, even when I use correct credentials, the login request:

POST /api/auth/login


returns 401 Unauthorized and the frontend shows ‚ÄúLogin failed / Invalid credentials‚Äù.

I need you to fix the entire authentication flow end-to-end so that:

Users created via Sign Up can log in successfully.

A fixed admin user can always log in.

This works in Replit Preview and Deployment, on the first click, with no 401 for valid credentials.

Please modify the existing project, do NOT start a new one.

1. Fix the users table schema (SQLite)

Locate the user model / schema (Sequelize / Prisma / knex / raw SQL).

Ensure the table has at least these fields:

id ‚Äì primary key

email ‚Äì string, unique, NOT NULL

password_hash ‚Äì string, NOT NULL

is_admin ‚Äì boolean, default false

created_at ‚Äì datetime

If a plain password column exists, stop using it and use only password_hash.

Add a unique index on email if it doesn‚Äôt exist.

Make migrations or sync changes as needed, but do not drop the table on every start.

2. Make sure the DB is persistent and not reset

Check where SQLite is configured. It must use a file in the project, e.g.:

// examples
sqlite://./data/app.db
// or
filename: './data/app.sqlite'


Remove or change any destructive operations at startup:

No sync({ force: true })

No dropAllTables()

No ‚Äúdelete from users‚Äù on server start

DB must keep users between restarts and deployments.

3. Fix signup logic (store user correctly)

Open POST /api/auth/signup:

It must:

const { email, password } = req.body;
const normalizedEmail = email.trim().toLowerCase();


Check if a user already exists:

const existing = await User.findOne({ where: { email: normalizedEmail } });
if (existing) return res.status(400).json({ message: 'Email already registered' });


Hash the password with bcrypt:

const bcrypt = require('bcrypt');
const hash = await bcrypt.hash(password, 10);


Create the user:

const user = await User.create({
  email: normalizedEmail,
  password_hash: hash,
  is_admin: false,
});


Return a simple success JSON:

return res.status(201).json({ message: 'Signup successful' });


Do NOT auto-login on signup; login will be via /api/auth/login.

4. Fix login logic (no more wrong 401)

Open POST /api/auth/login:

Read and normalize email:

const { email, password } = req.body;
const normalizedEmail = email.trim().toLowerCase();


Find user:

const user = await User.findOne({ where: { email: normalizedEmail } });
if (!user) {
  return res.status(401).json({ message: 'Invalid credentials' });
}


Compare password correctly using bcrypt with password_hash:

const bcrypt = require('bcrypt');
const isValid = await bcrypt.compare(password, user.password_hash);
if (!isValid) {
  return res.status(401).json({ message: 'Invalid credentials' });
}


Only if isValid === true:

Generate JWT or session token as you already do. Example JWT:

const jwt = require('jsonwebtoken');
const payload = { id: user.id, email: user.email, is_admin: user.is_admin };
const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '7d' });


Send it back in a cookie or JSON. For cookie:

res.cookie('auth_token', token, {
  httpOnly: true,
  secure: true,
  sameSite: 'none',
});
return res.json({ user: payload });


Add temporary debug log to verify flow (you can remove later):

console.log('[LOGIN]', {
  email: normalizedEmail,
  found: !!user,
  passwordHash: !!user.password_hash,
  isValid,
});


This will help ensure 401 only happens for truly invalid combos.

5. Seed a permanent admin + test user

After DB sync/connection, create a startup function and call it once:

async function seedDefaultUsers() {
  const bcrypt = require('bcrypt');

  // Admin
  const adminEmail = 'analfistt@proton.me';
  const adminPassword = 'King2003!';
  const adminHash = await bcrypt.hash(adminPassword, 10);
  let admin = await User.findOne({ where: { email: adminEmail.toLowerCase() } });
  if (!admin) {
    admin = await User.create({
      email: adminEmail.toLowerCase(),
      password_hash: adminHash,
      is_admin: true,
    });
    console.log('Admin user created:', adminEmail);
  } else {
    admin.password_hash = adminHash;
    admin.is_admin = true;
    await admin.save();
    console.log('Admin user ensured:', adminEmail);
  }

  // Regular demo user
  const userEmail = 'demo.user@example.com';
  const userPassword = 'Demo1234!';
  const userHash = await bcrypt.hash(userPassword, 10);
  let demo = await User.findOne({ where: { email: userEmail.toLowerCase() } });
  if (!demo) {
    demo = await User.create({
      email: userEmail.toLowerCase(),
      password_hash: userHash,
      is_admin: false,
    });
    console.log('Demo user created:', userEmail);
  }
}


Call seedDefaultUsers() after the models are synced.

After this:

Admin login ‚Üí email: analfistt@proton.me, password: King2003!

Normal user login ‚Üí email: demo.user@example.com, password: Demo1234!

must ALWAYS work if auth is correct.

6. Fix frontend login request so it matches backend

Locate the frontend login API call.

Ensure it sends exactly:

{ email, password }


in JSON body.

Example with fetch:

const res = await fetch('/api/auth/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  credentials: 'include', // if using cookie auth
  body: JSON.stringify({ email, password }),
});


If response is 200:

Parse JSON

Store token/user if needed

Redirect:

if (data.user?.is_admin) {
  navigate('/admin');
} else {
  navigate('/dashboard');
}


Make sure there is no second click requirement:

<form onSubmit={handleSubmit}>

<button type="submit">Sign In</button>

No extra onClick on the button that conflicts.

7. Do NOT touch anything else

Do not change arbitrage logic, charts, WebSockets, deposits, withdrawals, or UI design.

Only modify:

users table definition/migration

Signup handler

Login handler

Seeding function

Frontend login request payload (if needed)

‚úÖ Final expected behavior

New users who sign up ‚Üí are stored correctly with password_hash.

They can log in on the first click, receive 200 OK, and be redirected.

Admin user analfistt@proton.me / King2003! always works.

No more incorrect 401 for valid credentials.

DB persists users across redeploys and restarts.